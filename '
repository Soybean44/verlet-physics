#include "ball.hpp"
#include <cmath>
#include <iostream>
#include <raylib-cpp.hpp>

Ball::Ball(raylib::Vector2 pos, int s, raylib::Vector2 vel, Color c) {
	position = pos;
	size = s;
	color = c;
	time = 0.0; // time will be displayed on the screen in the future
	velocity = vel;
}

raylib::Vector2 Ball::getVector() {
	return position;
}
void Ball::Update(float dt, raylib::Vector2 a, int screenWidth, int screenHeight) {
	// ---- MAIN VERLET STUFF ---- //
	time += dt;
	// update verlet position
	position.y = position.y + velocity.y * dt + 0.5 * a.y * dt * dt;
	position.x = position.x + velocity.x * dt + 0.5 * a.x * dt * dt;
	velocity.y += a.y * dt;
	velocity.x += a.x * dt;

	// bounce on the bottom of the screen
	if (position.y+size > screenHeight) {
		position.y = screenHeight-size;

		// only dampen velocity to a certain point otherwise set it to 0
		if (velocity.y*velocity.y >= 2) { // square the velocity to account for sign
			velocity.y = -(velocity.y*0.5); // 0.5 is the damping factor, which may be tweaked
		} else {
			velocity.y = 0;
		}
	}
	// bounce on the sides of the screen
	if (position.x+size > screenWidth) {
		position.x = screenWidth-size;

		// only dampen velocity to a certain point otherwise set it to 0
		if (velocity.x*velocity.x >= 2) { // square the velocity to account for sign
			velocity.x = -(velocity.x*0.5); // 0.5 is the damping factor, which may be tweaked
		} else {
			velocity.x = 0;
		}
	} else if (position.x-size < 0) {
		position.x = size;

		// only dampen velocity to a certain point otherwise set it to 0
		if (velocity.x*velocity.x >= 2) { // square the velocity to account for sign
			velocity.x = -(velocity.x*0.5); // 0.5 is the damping factor, which may be tweaked
		} else {
			velocity.x = 0;
		}
	}
}

void Ball::Collide(Ball *b) {
	const raylib::Vector2 collision_axis = position - b->position;
	float dist = collision_axis.Length();
	if (dist < size+b->size) {
		const raylib::Vector2 n = collision_axis / dist;
		const float delta = (size+b->size)-dist;

		// static resolution
		position.x += 0.5f * delta * n.x;
		position.y += 0.5f * delta * n.y;
		b->position.x -= 0.5f * delta * n.x;
		b->position.y -= 0.5f * delta * n.y;

		// momentum
		float C = 100000;
		raylib::Vector2 r = collision_axis/velocity;
		float dt = 0.1;
		float pa = size*velocity.x;
		float pb = size*velocity.x;
		float F = (C*r.x)/std::pow(dist,3);
		pb = pb + F*dt;
		pa = pa - F*dt;
		b->velocity.x = pb/b->size;
		velocity.x = pa/size;
	}
}

void Ball::Draw() {
	DrawCircle(position.x, position.y, size, color);
}
